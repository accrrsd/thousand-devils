using Godot;
using System;
using System.Collections.Generic;
using GameSpace.Constants;
using GameSpace.PawnSpace;
using static UtilsSpace.UtilsFunctions;
using GameSpace.CellSpace.modules.logic;

namespace GameSpace.CellSpace;

public interface ICell
{
  bool IsOpen { get; set; }
  bool IsHighlighted { get; set; }
  CellType Type { get; }
  BaseLogic Logic { get; }
  Vector2 GridCords { get; }
  List<Pawn> Pawns { get; }

  void UpdateGridCords(Vector2 newCords);
}

public partial class Cell : Node3D, ICell
{
  // random by default and can be changed inside editor, if it still random - forceful change.
  [Export]
  public CellType Type { get; private set; } = CellType.Random;
  [Export]
  private GridMap _visibleCellElem;
  [Export]
  private PackedScene _invisibleCellScene;

  // that elem will be generated by _invisibleCellScene, and then will be put as child
  private GridMap _invisibleCellElem;

  private MeshInstance3D HighlightBorder;

  private bool _isOpen = false;
  public bool IsOpen
  {
    get { return _isOpen; }
    set
    {
      _isOpen = value;
      ChangeMapsVisibility(value);
    }
  }

  private bool _isHighlighted = false;
  public bool IsHighlighted
  {
    get { return _isHighlighted; }
    set
    {
      _isHighlighted = value;
      HighlightBorder.Visible = value;
    }
  }

  // after type was generated, we should find and set logic based on type.
  public BaseLogic Logic { get; private set; }
  public Vector2 GridCords { get; private set; }
  public List<Pawn> Pawns { get; private set; } = new();

  public override void _Ready()
  {
    base._Ready();
    _invisibleCellElem = UnpackInvisibleScene();
    ChangeTypeWhenRandom();
    FindModifierByType();
    // if ocean - cell visible by default
    ChangeMapsVisibility(Type == CellType.Ocean);
    AddChild(_invisibleCellElem);
    HighlightBorder = GetNode<MeshInstance3D>("HighlightBorder");
  }

  private void ChangeMapsVisibility(bool value)
  {
    if (value)
    {
      _visibleCellElem.Visible = true;
      _invisibleCellElem.Visible = false;
    }
    else
    {
      _visibleCellElem.Visible = false;
      _invisibleCellElem.Visible = true;
    }
  }

  private void ChangeTypeWhenRandom()
  {
    if (Type != CellType.Random) return;
    Type = GetRandomEnumValueExcluding(CellType.Random, CellType.Ocean);
  }

  private GridMap UnpackInvisibleScene()
  {
    Node instance = _invisibleCellScene?.Instantiate();
    if (_invisibleCellScene == null || instance is not GridMap) return GD.Load<PackedScene>("res://features/Game/components/cell/scenes/hidden_maps/Forest_1.tscn").Instantiate<GridMap>();
    return instance as GridMap;
  }

  private BaseLogic FindModifierByType()
  {
    return Type switch
    {
      CellType.Ocean => new OceanLogic(),
      CellType.Arrow => new ArrowLogic(),
      _ => null,
    };
  }

  public void UpdateGridCords(Vector2 newCords) => GridCords = newCords;
}