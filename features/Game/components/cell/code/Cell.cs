using System;
using System.Collections.Generic;
using Godot;
using ThousandDevils.features.Game.components.cell.code.modules.logic;
using ThousandDevils.features.Game.components.field.code;
using ThousandDevils.features.Game.components.pawn.code;
using ThousandDevils.features.Game.utils;
using ThousandDevils.features.GlobalUtils;
using static ThousandDevils.features.GlobalUtils.UtilsFunctions;

namespace ThousandDevils.features.Game.components.cell.code;

public partial class Cell : Node3D
{
  private MeshInstance3D _highlightBorder;

  // that elem will be generated by _invisibleCellScene, and then will be put as child
  private GridMap _invisibleCellElem;

  [Export] private PackedScene _invisibleCellScene;

  private bool _isHighlighted;

  private bool _isOpen;

  [Export] private GridMap _visibleCellElem;
  private List<Pawn> PawnsInside { get; } = new();

  public Field Field { get; private set; }

  // random by default and can be changed inside editor, if it still random - forceful change.
  [Export] public CellType Type { get; private set; } = CellType.Random;

  public bool IsOpen
  {
    get => _isOpen;
    set
    {
      _isOpen = value;
      ChangeMapsVisibility(value);
    }
  }

  public bool IsHighlighted
  {
    get => _isHighlighted;
    set
    {
      _isHighlighted = value;
      _highlightBorder.Visible = value;
    }
  }

  public Vector2I GridCords { get; set; }

  // after type was generated, we should find and set logic based on Type.
  public BaseLogic Logic { get; private set; }

  public void SetField(Field field)
  {
    Field = field;
  }

  public void AddPawn(Pawn pawn, bool callEvent = true)
  {
    if (PawnsInside.Contains(pawn)) return;
    PawnsInside.Add(pawn);
    AddChild(pawn);
    if (callEvent) PawnWasAdded?.Invoke(this, pawn);
  }

  public void RemovePawn(Pawn pawn, bool callEvent = true)
  {
    if (!PawnsInside.Contains(pawn)) return;
    PawnsInside.Remove(pawn);
    RemoveChild(pawn);
    if (callEvent) PawnWasRemoved?.Invoke(this, pawn);
  }

  public event Action<Cell, Pawn> PawnWasAdded;
  public event Action<Cell, Pawn> PawnWasRemoved;

  public override void _Ready()
  {
    base._Ready();
    _invisibleCellElem = UnpackInvisibleScene();
    ChangeTypeIfRandom();
    // default is false, but logic will set it if needed.
    ChangeMapsVisibility(false);
    Logic = CreateLogicByType();
    AddChild(_invisibleCellElem);
    _highlightBorder = GetNode<MeshInstance3D>("HighlightBorder");
  }

  private void ChangeMapsVisibility(bool value)
  {
    _visibleCellElem.Visible = value;
    _invisibleCellElem.Visible = !value;
  }

  private void ChangeTypeIfRandom()
  {
    if (Type != CellType.Random) return;
    Type = GetRandomEnumValueExcluding(CellType.Random, CellType.Ocean, CellType.Ship, CellType.PossibleShip);
  }

  private GridMap UnpackInvisibleScene()
  {
    GridMap instance = _invisibleCellScene?.Instantiate<GridMap>();
    if (_invisibleCellScene == null || instance == null)
      return LoadedPackedScenes.DefaultHiddenGridMapScene.Instantiate<GridMap>();
    return instance;
  }

  private BaseLogic CreateLogicByType()
  {
    return Type switch
    {
      CellType.Ocean => new OceanLogic(this),
      CellType.Arrow => new ArrowLogic(this),
      CellType.Ship => new ShipLogic(this),
      CellType.PossibleShip => new PossibleShipLogic(this),
      _ => null
    };
  }

  public IReadOnlyList<Pawn> GetPawns()
  {
    return PawnsInside.AsReadOnly();
  }
}
