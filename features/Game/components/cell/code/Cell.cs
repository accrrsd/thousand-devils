using Godot;
using System;
using System.Collections.Generic;
using GameSpace.Constants;
using GameSpace.PawnSpace;
using static UtilsSpace.UtilsFunctions;
using GameSpace.CellSpace.modules.logic;
using GameSpace.FieldSpace;

namespace GameSpace.CellSpace;

public interface ICell
{
  bool IsOpen { get; set; }
  bool IsHighlighted { get; set; }
  CellType Type { get; }
  BaseLogic Logic { get; }
  Vector2I GridCords { get; }
  List<Pawn> Pawns { get; }

  void UpdateGridCords(Vector2I newCords);
}

/*
В теории это можно переписать на абстрактный класс и реализовывать логику клеток прямо внутри клетки, просто наследуясь от Cell. Тогда будет много классов типа Cell_ocean, Cell_Arrow и т.п, что кажется логичным.
Но у моего метода есть одно сильное преимущество - логика клетки совершенно не зависит от ее внешнего вида, ведь она вынесена в отдельный модульный класс. Вместе с тем, в редакторе не приходится выставлять для каждой клетки новый скрипт, что тоже удобно.
У моего текущего метода только один недостаток - он менее понятный и слегка менее производительный из за switch. Но он невероятно выигрывает в гибкости и модульности, сохраняя базовый функционал Cell нетронутым.
*/
public partial class Cell : Node3D, ICell
{
  // random by default and can be changed inside editor, if it still random - forceful change.
  [Export]
  public CellType Type { get; private set; } = CellType.Random;
  [Export]
  private GridMap _visibleCellElem;
  [Export]
  private PackedScene _invisibleCellScene;

  // that elem will be generated by _invisibleCellScene, and then will be put as child
  private GridMap _invisibleCellElem;

  private MeshInstance3D HighlightBorder;

  private bool _isOpen = false;
  public bool IsOpen
  {
    get { return _isOpen; }
    set
    {
      _isOpen = value;
      ChangeMapsVisibility(value);
    }
  }

  private bool _isHighlighted = false;
  public bool IsHighlighted
  {
    get { return _isHighlighted; }
    set
    {
      _isHighlighted = value;
      HighlightBorder.Visible = value;
    }
  }

  public Vector2I GridCords { get; private set; }
  public List<Pawn> Pawns { get; private set; } = new();
  public Field Field { get; private set; }

  // after type was generated, we should find and set logic based on Type.
  public BaseLogic Logic { get; private set; }

  public override void _Ready()
  {
    base._Ready();
    _invisibleCellElem = UnpackInvisibleScene();
    ChangeTypeIfRandom();
    Logic = FindLogicByType();
    // if ocean - cell visible by default
    ChangeMapsVisibility(Type == CellType.Ocean || Type == CellType.Player);
    AddChild(_invisibleCellElem);
    HighlightBorder = GetNode<MeshInstance3D>("HighlightBorder");
  }

  private void ChangeMapsVisibility(bool value)
  {
    if (value)
    {
      _visibleCellElem.Visible = true;
      _invisibleCellElem.Visible = false;
    }
    else
    {
      _visibleCellElem.Visible = false;
      _invisibleCellElem.Visible = true;
    }
  }

  private void ChangeTypeIfRandom()
  {
    if (Type != CellType.Random) return;
    Type = GetRandomEnumValueExcluding(CellType.Random, CellType.Ocean, CellType.Player);
  }

  private GridMap UnpackInvisibleScene()
  {
    Node instance = _invisibleCellScene?.Instantiate();
    if (_invisibleCellScene == null || instance is not GridMap) return GD.Load<PackedScene>("res://features/Game/components/cell/scenes/hidden_maps/Forest_1.tscn").Instantiate<GridMap>();
    return instance as GridMap;
  }

  private BaseLogic FindLogicByType()
  {
    return Type switch
    {
      CellType.Ocean => new OceanLogic(this),
      CellType.Arrow => new ArrowLogic(this),
      CellType.Player => new PlayerLogic(this),
      _ => null,
    };
  }

  public void UpdateGridCords(Vector2I newCords) => GridCords = newCords;
  public void SetField(Field field)
  {
    Field = field;
  }
}